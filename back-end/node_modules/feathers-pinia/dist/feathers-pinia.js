var Vt = Object.defineProperty;
var Jt = (e, t, r) => t in e ? Vt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var be = (e, t, r) => (Jt(e, typeof t != "symbol" ? t + "" : t, r), r);
import { feathers as Kt } from "@feathersjs/feathers";
import { defineStore as zt } from "pinia";
import { unref as C, ref as j, isRef as J, computed as m, watch as ye, reactive as Be, set as R, del as G } from "vue-demi";
import { _ as ne } from "@feathersjs/commons";
import { sorter as Ht, select as He, filterQuery as Yt } from "@feathersjs/adapter-commons";
import { BadRequest as it } from "@feathersjs/errors";
import { FetchClient as Xt } from "@feathersjs/rest-client";
var fe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zt(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ye = function e(t, r) {
  if (t === r)
    return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor)
      return !1;
    var n, s, u;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length)
        return !1;
      for (s = n; s-- !== 0; )
        if (!e(t[s], r[s]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === r.toString();
    if (u = Object.keys(t), n = u.length, n !== Object.keys(r).length)
      return !1;
    for (s = n; s-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, u[s]))
        return !1;
    for (s = n; s-- !== 0; ) {
      var o = u[s];
      if (!e(t[o], r[o]))
        return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
}, er = Function.prototype.toString, we = Object.create, tr = Object.prototype.toString, rr = (
  /** @class */
  function() {
    function e() {
      this._keys = [], this._values = [];
    }
    return e.prototype.has = function(t) {
      return !!~this._keys.indexOf(t);
    }, e.prototype.get = function(t) {
      return this._values[this._keys.indexOf(t)];
    }, e.prototype.set = function(t, r) {
      this._keys.push(t), this._values.push(r);
    }, e;
  }()
);
function nr() {
  return new rr();
}
function sr() {
  return /* @__PURE__ */ new WeakMap();
}
var or = typeof WeakMap < "u" ? sr : nr;
function Me(e) {
  if (!e)
    return we(null);
  var t = e.constructor;
  if (t === Object)
    return e === Object.prototype ? {} : we(e);
  if (~er.call(t).indexOf("[native code]"))
    try {
      return new t();
    } catch {
    }
  return we(e);
}
function ir(e) {
  var t = "";
  return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.unicode && (t += "u"), e.sticky && (t += "y"), t;
}
function ur(e) {
  return e.flags;
}
var ar = /test/g.flags === "g" ? ur : ir;
function ut(e) {
  var t = tr.call(e);
  return t.substring(8, t.length - 1);
}
function cr(e) {
  return e[Symbol.toStringTag] || ut(e);
}
var lr = typeof Symbol < "u" ? cr : ut, fr = Object.defineProperty, dr = Object.getOwnPropertyDescriptor, at = Object.getOwnPropertyNames, Ne = Object.getOwnPropertySymbols, ct = Object.prototype, lt = ct.hasOwnProperty, pr = ct.propertyIsEnumerable, ft = typeof Ne == "function";
function hr(e) {
  return at(e).concat(Ne(e));
}
var vr = ft ? hr : at;
function me(e, t, r) {
  for (var n = vr(e), s = 0, u = n.length, o = void 0, i = void 0; s < u; ++s)
    if (o = n[s], !(o === "callee" || o === "caller")) {
      if (i = dr(e, o), !i) {
        t[o] = r.copier(e[o], r);
        continue;
      }
      !i.get && !i.set && (i.value = r.copier(i.value, r));
      try {
        fr(t, o, i);
      } catch {
        t[o] = i.value;
      }
    }
  return t;
}
function yr(e, t) {
  var r = new t.Constructor();
  t.cache.set(e, r);
  for (var n = 0, s = e.length; n < s; ++n)
    r[n] = t.copier(e[n], t);
  return r;
}
function mr(e, t) {
  var r = new t.Constructor();
  return t.cache.set(e, r), me(e, r, t);
}
function dt(e, t) {
  return e.slice(0);
}
function gr(e, t) {
  return e.slice(0, e.size, e.type);
}
function Sr(e, t) {
  return new t.Constructor(dt(e.buffer));
}
function Ir(e, t) {
  return new t.Constructor(e.getTime());
}
function pt(e, t) {
  var r = new t.Constructor();
  return t.cache.set(e, r), e.forEach(function(n, s) {
    r.set(s, t.copier(n, t));
  }), r;
}
function Or(e, t) {
  return me(e, pt(e, t), t);
}
function br(e, t) {
  var r = Me(t.prototype);
  t.cache.set(e, r);
  for (var n in e)
    lt.call(e, n) && (r[n] = t.copier(e[n], t));
  return r;
}
function wr(e, t) {
  var r = Me(t.prototype);
  t.cache.set(e, r);
  for (var n in e)
    lt.call(e, n) && (r[n] = t.copier(e[n], t));
  for (var s = Ne(e), u = 0, o = s.length, i = void 0; u < o; ++u)
    i = s[u], pr.call(e, i) && (r[i] = t.copier(e[i], t));
  return r;
}
var _r = ft ? wr : br;
function $r(e, t) {
  var r = Me(t.prototype);
  return t.cache.set(e, r), me(e, r, t);
}
function _e(e, t) {
  return new t.Constructor(e.valueOf());
}
function Pr(e, t) {
  var r = new t.Constructor(e.source, ar(e));
  return r.lastIndex = e.lastIndex, r;
}
function de(e, t) {
  return e;
}
function ht(e, t) {
  var r = new t.Constructor();
  return t.cache.set(e, r), e.forEach(function(n) {
    r.add(t.copier(n, t));
  }), r;
}
function jr(e, t) {
  return me(e, ht(e, t), t);
}
var kr = Array.isArray, De = Object.assign, Er = Object.getPrototypeOf || function(e) {
  return e.__proto__;
}, vt = {
  array: yr,
  arrayBuffer: dt,
  blob: gr,
  dataView: Sr,
  date: Ir,
  error: de,
  map: pt,
  object: _r,
  regExp: Pr,
  set: ht
}, Ar = De({}, vt, {
  array: mr,
  map: Or,
  object: $r,
  set: jr
});
function qr(e) {
  return {
    Arguments: e.object,
    Array: e.array,
    ArrayBuffer: e.arrayBuffer,
    Blob: e.blob,
    Boolean: _e,
    DataView: e.dataView,
    Date: e.date,
    Error: e.error,
    Float32Array: e.arrayBuffer,
    Float64Array: e.arrayBuffer,
    Int8Array: e.arrayBuffer,
    Int16Array: e.arrayBuffer,
    Int32Array: e.arrayBuffer,
    Map: e.map,
    Number: _e,
    Object: e.object,
    Promise: de,
    RegExp: e.regExp,
    Set: e.set,
    String: _e,
    WeakMap: de,
    WeakSet: de,
    Uint8Array: e.arrayBuffer,
    Uint8ClampedArray: e.arrayBuffer,
    Uint16Array: e.arrayBuffer,
    Uint32Array: e.arrayBuffer,
    Uint64Array: e.arrayBuffer
  };
}
function yt(e) {
  var t = De({}, vt, e), r = qr(t), n = r.Array, s = r.Object;
  function u(o, i) {
    if (i.prototype = i.Constructor = void 0, !o || typeof o != "object")
      return o;
    if (i.cache.has(o))
      return i.cache.get(o);
    if (i.prototype = Er(o), i.Constructor = i.prototype && i.prototype.constructor, !i.Constructor || i.Constructor === Object)
      return s(o, i);
    if (kr(o))
      return n(o, i);
    var a = r[lr(o)];
    return a ? a(o, i) : typeof o.then == "function" ? o : s(o, i);
  }
  return function(i) {
    return u(i, {
      Constructor: void 0,
      cache: or(),
      copier: u,
      prototype: void 0
    });
  };
}
function Cr(e) {
  return yt(De({}, Ar, e));
}
Cr({});
var X = yt({});
const ce = (e, t) => (Object.keys(t).forEach((r) => {
  Object.defineProperty(e, r, {
    enumerable: !1,
    configurable: !0,
    value: t[r]
  });
}), e), mt = (e, t) => (Object.keys(t).forEach((r) => {
  Object.defineProperty(e, r, {
    enumerable: !1,
    configurable: !0,
    get: t[r]
  });
}), e), Cs = (e, t) => (Object.keys(t).forEach((r) => {
  Object.defineProperty(e, r, {
    enumerable: !1,
    configurable: !0,
    set: t[r]
  });
}), e);
function re(e, t) {
  return t && (Array.isArray(t) ? t.map((r) => e.new(r)) : t && Array.isArray(t.data) ? (t.data = t.data.map((r) => e.new(r)), t) : e.new(t));
}
function $e({ queryInfo: e, service: t, store: r, qid: n }) {
  const u = r.pagination[n.value][e.queryId];
  if (!u)
    return null;
  const { total: o } = u, i = u[e.pageId];
  if (!i)
    return null;
  const { ids: a, queriedAt: c, ssr: l } = i, d = a.map((S) => r.itemsById[S]).filter((S) => S), g = re(t, d);
  return { ...e, ids: a, items: g, total: o, queriedAt: c, queryState: u, ssr: l } || null;
}
function K(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Y(e) {
  const t = Array.isArray(e);
  return { items: t ? e : [e], isArray: t };
}
function je(e, t) {
  if (!t)
    return e;
  const n = (typeof t == "string" ? [t] : Array.isArray(t) ? t : Object.keys(t || e)).map((s) => s.toString().split(".")[0]);
  return ne.pick(e, ...n);
}
function Fr(e, t, r) {
  const n = je(e, r), s = je(t, r);
  return typeof r != "string" && !Array.isArray(r) && Object.assign(s, r), Ye(n, s) ? {} : Object.keys(s).reduce((i, a) => (Ye(e[a], s[a]) || (i[a] = s[a]), i), {});
}
function Tr(e, t, r = "__tempId") {
  const { items: n, isArray: s } = Y(e), { items: u } = Y(t);
  return u.forEach((o, i) => {
    const a = n[i][r];
    a && ce(o, { [r]: a });
  }), s ? u : u[0];
}
function Pe(e) {
  return typeof e == "object" && e != null ? e.toString() : e;
}
function pe(e, t) {
  if (e) {
    if (t && e[t] !== void 0)
      return Pe(e[t]);
    if (e.id !== void 0)
      return Pe(e.id);
    if (e._id !== void 0)
      return Pe(e._id);
  }
}
function te(e) {
  return e ? X(C(e)) : {};
}
function ue(e) {
  return new Promise((t) => setTimeout(t, e));
}
const Xe = () => {
  const e = j(0);
  return { count: e, add: () => {
    e.value = e.value + 1;
  }, sub: () => {
    e.value = e.value === 0 ? 0 : e.value - 1;
  } };
}, Lr = (e) => e !== null && typeof e == "object", Br = Array.isArray;
function W(e) {
  const t = J(e) ? C(e) : e;
  return Lr(t) ? Br(t) ? Mr(t) : Nr(t) : t;
}
const gt = (e) => e !== null && !J(e) && typeof e == "object" ? W(e) : C(e), Mr = (e) => e.map(gt), Nr = (e) => {
  const t = {};
  return Object.keys(e).forEach((r) => {
    t[r] = gt(e[r]);
  }), t;
}, Fs = (e, t) => {
  const r = Object.keys(t), n = ne.omit(e, ...r);
  return Object.assign(t, X(n));
};
function Ze(e) {
  return typeof e == "function" ? e() : C(e);
}
const et = () => {
};
function Dr(e, t) {
  function r(...n) {
    return new Promise((s, u) => {
      Promise.resolve(e(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(s).catch(u);
    });
  }
  return r;
}
function Rr(e, t = {}) {
  let r, n, s = et;
  const u = (i) => {
    clearTimeout(i), s(), s = et;
  };
  return (i) => {
    const a = Ze(e), c = Ze(t.maxWait);
    return r && u(r), a <= 0 || c !== void 0 && c <= 0 ? (n && (u(n), n = null), Promise.resolve(i())) : new Promise((l, d) => {
      s = t.rejectOnCancel ? d : l, c && !n && (n = setTimeout(() => {
        r && u(r), n = null, l(i());
      }, c)), r = setTimeout(() => {
        n && u(n), n = null, l(i());
      }, a);
    });
  };
}
function Wr(e, t = 200, r = {}) {
  return Dr(
    Rr(t, r),
    e
  );
}
var he = function(e, t) {
  t || (t = {}), typeof t == "function" && (t = { cmp: t });
  var r = typeof t.cycles == "boolean" ? t.cycles : !1, n = t.cmp && function(u) {
    return function(o) {
      return function(i, a) {
        var c = { key: i, value: o[i] }, l = { key: a, value: o[a] };
        return u(c, l);
      };
    };
  }(t.cmp), s = [];
  return function u(o) {
    if (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()), o !== void 0) {
      if (typeof o == "number")
        return isFinite(o) ? "" + o : "null";
      if (typeof o != "object")
        return JSON.stringify(o);
      var i, a;
      if (Array.isArray(o)) {
        for (a = "[", i = 0; i < o.length; i++)
          i && (a += ","), a += u(o[i]) || "null";
        return a + "]";
      }
      if (o === null)
        return "null";
      if (s.indexOf(o) !== -1) {
        if (r)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var c = s.push(o) - 1, l = Object.keys(o).sort(n && n(o));
      for (a = "", i = 0; i < l.length; i++) {
        var d = l[i], g = u(o[d]);
        g && (a && (a += ","), a += JSON.stringify(d) + ":" + g);
      }
      return s.splice(c, 1), "{" + a + "}";
    }
  }(e);
};
function Gr(e, t) {
  const { queryId: r, pageId: n } = t, s = e[r], u = s && s[n];
  return u && u.ids || [];
}
function xr(e, t, r) {
  const n = r.qid || "default", s = e.pagination[n] || {}, u = e.getQueryInfo(r);
  return Gr(s, u).map((a) => t.getFromStore(a).value).filter((a) => a);
}
function Qr(e) {
  const { limit: t, skip: r, total: n, request: s } = e, u = m(() => n.value ? Math.ceil(n.value / t.value) : 1), o = m({
    set(v) {
      v < 1 ? v = 1 : v > u.value && (v = u.value);
      const b = t.value * Math.floor(v - 1);
      r.value = b;
    },
    get() {
      const v = r.value || 0;
      return u.value === 0 ? 0 : Math.floor(v / t.value + 1);
    }
  }), i = m(() => o.value - 1 > 0), a = m(() => o.value < u.value), c = async () => {
    s != null && s.value && await s.value;
  };
  return { pageCount: u, currentPage: o, canPrev: i, canNext: a, toStart: async () => (o.value = 1, await ue(0), c()), toEnd: async () => (o.value = u.value, await ue(0), c()), toPage: async (v) => (o.value = v, await ue(0), c()), next: async () => (o.value++, await ue(0), c()), prev: async () => (o.value--, await ue(0), c()) };
}
function Ur(e, t = {}, r) {
  var Ve, Je, Ke, ze;
  const { pagination: n, debounce: s = 100, immediate: u = !0, watch: o = !0, paginateOn: i = "client" } = t, { service: a } = r, { store: c } = a, l = m(() => {
    var k;
    return ((k = e.value) == null ? void 0 : k.qid) || "default";
  }), d = (n == null ? void 0 : n.limit) || j(((Je = (Ve = e.value) == null ? void 0 : Ve.query) == null ? void 0 : Je.$limit) || c.defaultLimit), g = (n == null ? void 0 : n.skip) || j(((ze = (Ke = e.value) == null ? void 0 : Ke.query) == null ? void 0 : ze.$skip) || 0), f = m(() => {
    var L;
    const k = W(((L = e.value) == null ? void 0 : L.query) || {});
    return {
      ...e.value,
      query: {
        ...k,
        $limit: d.value,
        $skip: g.value
      }
    };
  }), S = m(() => {
    var ee;
    const k = W(((ee = e.value) == null ? void 0 : ee.query) || {}), L = ne.omit(k, "$limit", "$skip");
    return { ...e.value, query: L };
  }), v = j(!1), b = j(!1), w = j(!1), y = j(null), O = () => y.value = null, h = j(W(e.value || {}));
  function I() {
    he(h.value) !== he(f.value) && (h.value = f.value);
  }
  const p = m(() => {
    const k = $.value, L = g.value + (k.length - g.value);
    return {
      ...f.value,
      query: {
        ...f.value.query,
        $limit: d.value,
        $skip: L
      }
    };
  }), _ = m(() => i === "server" ? xr(c, a, h.value) : i === "hybrid" ? a.findInStore(W(p)).data.value.filter((L) => L) : a.findInStore(W(f)).data.value.filter((L) => L)), $ = m(() => {
    const k = v.value ? M.value : A.value;
    if (k == null)
      return [];
    const L = P.value, D = k.items.find((Oe) => Oe), ee = L.findIndex((Oe) => Oe[c.idField] === D[c.idField]), le = Math.min(ee, g.value);
    return L.slice(0, le);
  }), P = m(() => (v.value ? M.value : A.value) == null && i !== "client" ? [] : a.findInStore(W(S.value)).data.value);
  let q = () => !0;
  const F = (k) => {
    q = k;
  }, M = m(() => {
    if (!c.pagination[l.value])
      return null;
    const L = c.getQueryInfo(h.value);
    return $e({ queryInfo: L, service: a, store: c, qid: l });
  }), A = m(() => {
    if (!c.pagination[l.value])
      return null;
    const L = c.getQueryInfo(f.value);
    return $e({ queryInfo: L, service: a, store: c, qid: l });
  }), N = j([]), E = m(() => N.value[N.value.length - 1] || null), T = m(() => N.value[N.value.length - 2] || null), x = j(0), H = j(null);
  function Ue() {
    var k;
    (k = A.value) != null && k.ssr || (b.value || (b.value = !0), O(), v.value || (v.value = !0), w.value && (w.value = !1));
  }
  async function Tt(k) {
    const L = C(k ?? (i === "client" ? S.value : f.value));
    if (!q())
      return Promise.resolve({ data: [] });
    Ue(), x.value++;
    try {
      const D = await a.find(L);
      if (D.total) {
        const ee = c.getQueryInfo(f.value), le = $e({ queryInfo: ee, service: a, store: c, qid: l });
        le && N.value.push(le), N.value.length > 2 && N.value.shift();
      }
      return w.value = !0, D;
    } catch (D) {
      throw y.value = D, D;
    } finally {
      v.value = !1;
    }
  }
  const Lt = Wr(Tt, s), Z = async (k) => {
    e.value !== null && (A.value && I(), q() && Ue(), H.value = Lt(k), await H.value, I());
  }, Ie = m(() => {
    if (["server", "hybrid"].includes(i)) {
      const k = A.value || M.value;
      return (k == null ? void 0 : k.total) || 0;
    } else
      return a.countInStore(S.value).value;
  }), Bt = Qr({ limit: d, skip: g, total: Ie, request: H }), { pageCount: Mt, currentPage: Nt, canPrev: Dt, canNext: Rt, toStart: Wt, toEnd: Gt, toPage: xt, next: Qt, prev: Ut } = Bt;
  return ["server", "hybrid"].includes(i) && o && (ye(
    f,
    () => {
      Z();
    },
    { immediate: !1 }
  ), u && Z()), i === "server" && (a.on("created", () => {
    Z();
  }), a.on("patched", () => {
    Z();
  }), a.on("removed", () => {
    Z();
  })), {
    paramsWithPagination: f,
    isSsr: m(() => (setTimeout(() => {
      j(Ie.value);
    }, 0), c.isSsr)),
    // ComputedRef<boolean>
    qid: l,
    // WritableComputedRef<string>
    // Data
    data: _,
    // ComputedRef<M[]>
    allLocalData: P,
    // ComputedRef<M[]>
    total: Ie,
    // ComputedRef<number>
    limit: d,
    // Ref<number>
    skip: g,
    // Ref<number>
    // Queries
    currentQuery: A,
    // ComputedRef<CurrentQuery<M> | null>
    cachedQuery: M,
    // ComputedRef<CurrentQuery<M> | null>
    latestQuery: E,
    // ComputedRef<QueryInfo | null>
    previousQuery: T,
    // ComputedRef<QueryInfo | null>
    // Requests & Watching
    find: Z,
    // FindFn<M>
    request: H,
    // Ref<Promise<Paginated<M>>>
    requestCount: x,
    // Ref<number>
    queryWhen: F,
    // (queryWhenFn: () => boolean) => void
    // Request State
    isPending: m(() => v.value),
    // ComputedRef<boolean>
    haveBeenRequested: m(() => b.value),
    // ComputedRef<boolean>
    haveLoaded: m(() => w.value),
    // ComputedRef<boolean>
    error: m(() => y.value),
    // ComputedRef<any>
    clearError: O,
    // () => void
    // Pagination Utils
    pageCount: Mt,
    // Ref<number>
    currentPage: Nt,
    // Ref<number>
    canPrev: Dt,
    // ComputedRef<boolean>
    canNext: Rt,
    // ComputedRef<boolean>
    next: Qt,
    // () => Promise<void>
    prev: Ut,
    // () => Promise<void>
    toStart: Wt,
    // () => Promise<void>
    toEnd: Gt,
    // () => Promise<void>
    toPage: xt
    // (page: number) => Promise<void>
  };
}
const Vr = (e, t = j({}), r) => {
  const { service: n } = r, s = J(e) ? e : j(e), u = J(t) ? t : j(t), { immediate: o = !0, watch: i = !0 } = u.value, a = m(() => n.store.isSsr), c = j(!1), l = j(!1), d = j(null), g = () => d.value = null, f = j([]), S = m(() => f.value.length && f.value[f.value.length - 1]), v = m(() => c.value && S.value != null ? n.store.getFromStore(S.value, u).value : n.store.getFromStore(s.value, u).value), b = n.store.getFromStore, w = m(() => !!v.value);
  let y = () => !0;
  const O = ($) => {
    y = $;
  }, h = j(0), I = j(null);
  async function p() {
    const $ = C(s), P = C(u);
    if (y()) {
      if ($ == null)
        return null;
      h.value++, l.value = !0, c.value = !0, d.value = null;
      try {
        const q = await n.get($, P);
        return q && $ && f.value.push($), q;
      } catch (q) {
        d.value = q;
      } finally {
        c.value = !1;
      }
    }
  }
  async function _() {
    return I.value = p(), await I.value;
  }
  return i && ye(
    s,
    async () => {
      await _();
    },
    { immediate: o }
  ), {
    params: u,
    // Ref<GetClassParams>
    isSsr: a,
    // ComputedRef<boolean>
    // Data
    data: v,
    // ComputedRef<M | null>
    ids: f,
    // Ref<Id[]>
    getFromStore: b,
    // (id: Id | null, params: Params<Query>) => M | undefined
    // Requests & Watching
    get: _,
    // GetFn<M>
    request: I,
    // Ref<Promise<M | undefined>>
    requestCount: h,
    // Ref<number>
    queryWhen: O,
    // (queryWhenFn: () => boolean) => void
    // Request State
    isPending: m(() => c.value),
    // ComputedRef<boolean>
    hasBeenRequested: m(() => l.value),
    // ComputedRef<boolean>
    hasLoaded: m(() => w.value),
    // ComputedRef<boolean>
    error: m(() => d.value),
    // ComputedRef<any>
    clearError: g
    // () => void
  };
};
class Jr {
  constructor(t, r) {
    be(this, "store");
    be(this, "servicePath", "");
    this.service = t, this.options = r, this.store = r.store, this.servicePath = r.servicePath;
  }
  /**
   * Prepare new "instances" outside of store
   *
   * Functionally upgrades plain data to a service model "instance".
   * - flags each record with `__isSetup` to avoid duplicate work.
   */
  new(t = {}) {
    const r = this.store.new(t);
    return Be(r);
  }
  /* service methods clone params */
  async find(t) {
    const r = te(t);
    return await this.service.find(r);
  }
  async findOne(t) {
    const r = te(t);
    r.query = r.query || {}, r.query.$limit = 1;
    const n = await this.service.find(r);
    return (n.data || n)[0] || null;
  }
  async count(t) {
    const r = te(t);
    return r.query = r.query || {}, r.query.$limit = 0, await this.service.find(r);
  }
  async get(t, r) {
    const n = te(r);
    return await this.service.get(t, n);
  }
  async create(t) {
    return await this.service.create(t);
  }
  async patch(t, r, n) {
    const s = te(n);
    return await this.service.patch(t, r, s);
  }
  async remove(t, r) {
    const n = te(r);
    return await this.service.remove(t, n);
  }
  /* store methods accept refs and don't copy params */
  findInStore(t) {
    const r = this.store.findInStore(t);
    return {
      ...r,
      data: m(() => r.data.value.map((n) => re(this, n)))
    };
  }
  findOneInStore(t) {
    return this.store.findOneInStore(t);
  }
  countInStore(t) {
    return this.store.countInStore(t);
  }
  getFromStore(t, r) {
    return this.store.getFromStore(t, r);
  }
  createInStore(t) {
    return this.store.createInStore(t);
  }
  patchInStore(t, r = {}, n = {}) {
    return this.store.patchInStore(t, r, n);
  }
  removeFromStore(t, r) {
    var s;
    const n = t != null ? this.getFromStore(t).value : null;
    if (n)
      return this.store.removeFromStore(n);
    if (t == null && ((s = C(r)) != null && s.query))
      return this.store.removeByQuery(r);
  }
  /* hybrid methods */
  useFind(t, r) {
    const n = J(t) ? t : j(t);
    return Ur(n, r, { service: this });
  }
  useGet(t, r = j({})) {
    const n = J(t) ? t : j(t), s = J(r) ? r : j(r);
    return Vr(n, s, { service: this });
  }
  useGetOnce(t, r = {}) {
    const n = J(r) ? r : j(r);
    Object.assign(n.value, { immediate: !1 });
    const s = this.useGet(t, n);
    return s.queryWhen(() => !s.data.value), s.get(), s;
  }
  /* events */
  on(t, r) {
    return this.service.on(t, r);
  }
  emit(t, ...r) {
    return this.service.emit(t, ...r);
  }
  removeListener(t, r) {
    return this.service.removeListener(t, r);
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ke = function(e, t) {
  return ke = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var s in n)
      Object.prototype.hasOwnProperty.call(n, s) && (r[s] = n[s]);
  }, ke(e, t);
};
function B(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  ke(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var Re = function(e) {
  var t = "[object " + e + "]";
  return function(r) {
    return Kr(r) === t;
  };
}, Kr = function(e) {
  return Object.prototype.toString.call(e);
}, se = function(e) {
  return e instanceof Date ? e.getTime() : oe(e) ? e.map(se) : e && typeof e.toJSON == "function" ? e.toJSON() : e;
}, zr = function(e) {
  return e ?? null;
}, oe = Re("Array"), Hr = Re("Object"), Yr = Re("Function"), Xr = function(e) {
  return e && (e.constructor === Object || e.constructor === Array || e.constructor.toString() === "function Object() { [native code] }" || e.constructor.toString() === "function Array() { [native code] }") && !e.toJSON;
}, Ee = function(e, t) {
  if (e == null && e == t || e === t)
    return !0;
  if (Object.prototype.toString.call(e) !== Object.prototype.toString.call(t))
    return !1;
  if (oe(e)) {
    if (e.length !== t.length)
      return !1;
    for (var r = 0, n = e.length; r < n; r++)
      if (!Ee(e[r], t[r]))
        return !1;
    return !0;
  } else if (Hr(e)) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (var s in e)
      if (!Ee(e[s], t[s]))
        return !1;
    return !0;
  }
  return !1;
}, Ae = function(e, t, r, n, s, u) {
  var o = t[n];
  if (oe(e) && isNaN(Number(o))) {
    for (var i = 0, a = e.length; i < a; i++)
      if (!Ae(e[i], t, r, n, i, e))
        return !1;
  }
  return n === t.length || e == null ? r(e, s, u, n === 0) : Ae(e[o], t, r, n + 1, o, e);
}, Q = (
  /** @class */
  function() {
    function e(t, r, n, s) {
      this.params = t, this.owneryQuery = r, this.options = n, this.name = s, this.init();
    }
    return e.prototype.init = function() {
    }, e.prototype.reset = function() {
      this.done = !1, this.keep = !1;
    }, e;
  }()
), We = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u) {
      var o = e.call(this, r, n, s) || this;
      return o.children = u, o;
    }
    return t.prototype.reset = function() {
      this.keep = !1, this.done = !1;
      for (var r = 0, n = this.children.length; r < n; r++)
        this.children[r].reset();
    }, t.prototype.childrenNext = function(r, n, s, u) {
      for (var o = !0, i = !0, a = 0, c = this.children.length; a < c; a++) {
        var l = this.children[a];
        if (l.done || l.next(r, n, s, u), l.keep || (i = !1), l.done) {
          if (!l.keep)
            break;
        } else
          o = !1;
      }
      this.done = o, this.keep = i;
    }, t;
  }(Q)
), St = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u, o) {
      var i = e.call(this, r, n, s, u) || this;
      return i.name = o, i;
    }
    return t;
  }(We)
), Zr = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.next = function(r, n, s, u) {
      this.childrenNext(r, n, s, u);
    }, t;
  }(We)
), qe = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u, o) {
      var i = e.call(this, n, s, u, o) || this;
      return i.keyPath = r, i.propop = !0, i._nextNestedValue = function(a, c, l, d) {
        return i.childrenNext(a, c, l, d), !i.done;
      }, i;
    }
    return t.prototype.next = function(r, n, s) {
      Ae(r, this.keyPath, this._nextNestedValue, 0, n, s);
    }, t;
  }(We)
), Ge = function(e, t) {
  if (e instanceof Function)
    return e;
  if (e instanceof RegExp)
    return function(n) {
      var s = typeof n == "string" && e.test(n);
      return e.lastIndex = 0, s;
    };
  var r = se(e);
  return function(n) {
    return t(r, se(n));
  };
}, V = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
      this._test = Ge(this.params, this.options.compare);
    }, t.prototype.next = function(r, n, s) {
      (!Array.isArray(s) || s.hasOwnProperty(n)) && this._test(r, n, s) && (this.done = !0, this.keep = !0);
    }, t;
  }(Q)
), ge = function(e, t, r) {
  return new V(e, t, r);
}, en = function(e) {
  return function(t, r, n, s) {
    return e(t, r, n, s);
  };
}, Se = function(e) {
  return en(function(t, r, n, s) {
    var u = typeof se(t), o = e(t);
    return new V(function(i) {
      var a = zr(i);
      return typeof se(a) === u && o(a);
    }, r, n, s);
  });
}, tn = function(e, t, r, n) {
  var s = n.operations[e];
  return s || It(e), s(t, r, n, e);
}, It = function(e) {
  throw new Error("Unsupported operation: " + e);
}, Ot = function(e, t) {
  for (var r in e)
    if (t.operations.hasOwnProperty(r) || r.charAt(0) === "$")
      return !0;
  return !1;
}, rn = function(e, t, r, n, s) {
  if (Ot(t, s)) {
    var u = bt(t, r, s), o = u[0], i = u[1];
    if (i.length)
      throw new Error("Property queries must contain only operations, or exact objects.");
    return new qe(e, t, n, s, o);
  }
  return new qe(e, t, n, s, [
    new V(t, n, s)
  ]);
}, ie = function(e, t, r) {
  t === void 0 && (t = null);
  var n = r === void 0 ? {} : r, s = n.compare, u = n.operations, o = {
    compare: s || Ee,
    operations: Object.assign({}, u || {})
  }, i = bt(e, null, o), a = i[0], c = i[1], l = [];
  return a.length && l.push(new qe([], e, t, o, a)), l.push.apply(l, c), l.length === 1 ? l[0] : new Zr(e, t, o, l);
}, bt = function(e, t, r) {
  var n = [], s = [];
  if (!Xr(e))
    return n.push(new V(e, e, r)), [n, s];
  for (var u in e)
    if (r.operations.hasOwnProperty(u)) {
      var o = tn(u, e[u], e, r);
      if (o && !o.propop && t && !r.operations[t])
        throw new Error("Malformed query. " + u + " cannot be matched against property.");
      o != null && n.push(o);
    } else
      u.charAt(0) === "$" ? It(u) : s.push(rn(u.split("."), e[u], u, e, r));
  return [n, s];
}, nn = function(e) {
  return function(t, r, n) {
    return e.reset(), e.next(t, r, n), e.keep;
  };
}, sn = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
      this._test = Ge(this.params, this.options.compare);
    }, t.prototype.reset = function() {
      e.prototype.reset.call(this), this.keep = !0;
    }, t.prototype.next = function(r) {
      this._test(r) && (this.done = !0, this.keep = !1);
    }, t;
  }(Q)
), on = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
      if (!this.params || typeof this.params != "object")
        throw new Error("Malformed query. $elemMatch must by an object.");
      this._queryOperation = ie(this.params, this.owneryQuery, this.options);
    }, t.prototype.reset = function() {
      e.prototype.reset.call(this), this._queryOperation.reset();
    }, t.prototype.next = function(r) {
      if (oe(r)) {
        for (var n = 0, s = r.length; n < s; n++) {
          this._queryOperation.reset();
          var u = r[n];
          this._queryOperation.next(u, n, r, !1), this.keep = this.keep || this._queryOperation.keep;
        }
        this.done = !0;
      } else
        this.done = !1, this.keep = !1;
    }, t;
  }(Q)
), un = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
      this._queryOperation = ie(this.params, this.owneryQuery, this.options);
    }, t.prototype.reset = function() {
      e.prototype.reset.call(this), this._queryOperation.reset();
    }, t.prototype.next = function(r, n, s, u) {
      this._queryOperation.next(r, n, s, u), this.done = this._queryOperation.done, this.keep = !this._queryOperation.keep;
    }, t;
  }(Q)
), wt = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
    }, t.prototype.next = function(r) {
      oe(r) && r.length === this.params && (this.done = !0, this.keep = !0);
    }, t;
  }(Q)
), _t = function(e) {
  if (e.length === 0)
    throw new Error("$and/$or/$nor must be a nonempty array");
}, $t = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !1, r;
    }
    return t.prototype.init = function() {
      var r = this;
      _t(this.params), this._ops = this.params.map(function(n) {
        return ie(n, null, r.options);
      });
    }, t.prototype.reset = function() {
      this.done = !1, this.keep = !1;
      for (var r = 0, n = this._ops.length; r < n; r++)
        this._ops[r].reset();
    }, t.prototype.next = function(r, n, s) {
      for (var u = !1, o = !1, i = 0, a = this._ops.length; i < a; i++) {
        var c = this._ops[i];
        if (c.next(r, n, s), c.keep) {
          u = !0, o = c.keep;
          break;
        }
      }
      this.keep = o, this.done = u;
    }, t;
  }(Q)
), an = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !1, r;
    }
    return t.prototype.next = function(r, n, s) {
      e.prototype.next.call(this, r, n, s), this.keep = !this.keep;
    }, t;
  }($t)
), Pt = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.init = function() {
      var r = this;
      this._testers = this.params.map(function(n) {
        if (Ot(n, r.options))
          throw new Error("cannot nest $ under " + r.name.toLowerCase());
        return Ge(n, r.options.compare);
      });
    }, t.prototype.next = function(r, n, s) {
      for (var u = !1, o = !1, i = 0, a = this._testers.length; i < a; i++) {
        var c = this._testers[i];
        if (c(r)) {
          u = !0, o = !0;
          break;
        }
      }
      this.keep = o, this.done = u;
    }, t;
  }(Q)
), cn = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u) {
      var o = e.call(this, r, n, s, u) || this;
      return o.propop = !0, o._in = new Pt(r, n, s, u), o;
    }
    return t.prototype.next = function(r, n, s, u) {
      this._in.next(r, n, s), oe(s) && !u ? this._in.keep ? (this.keep = !1, this.done = !0) : n == s.length - 1 && (this.keep = !0, this.done = !0) : (this.keep = !this._in.keep, this.done = !0);
    }, t.prototype.reset = function() {
      e.prototype.reset.call(this), this._in.reset();
    }, t;
  }(Q)
), ln = (
  /** @class */
  function(e) {
    B(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.propop = !0, r;
    }
    return t.prototype.next = function(r, n, s) {
      s.hasOwnProperty(n) === this.params && (this.done = !0, this.keep = !0);
    }, t;
  }(Q)
), fn = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u) {
      var o = e.call(this, r, n, s, r.map(function(i) {
        return ie(i, n, s);
      }), u) || this;
      return o.propop = !1, _t(r), o;
    }
    return t.prototype.next = function(r, n, s, u) {
      this.childrenNext(r, n, s, u);
    }, t;
  }(St)
), dn = (
  /** @class */
  function(e) {
    B(t, e);
    function t(r, n, s, u) {
      var o = e.call(this, r, n, s, r.map(function(i) {
        return ie(i, n, s);
      }), u) || this;
      return o.propop = !0, o;
    }
    return t.prototype.next = function(r, n, s, u) {
      this.childrenNext(r, n, s, u);
    }, t;
  }(St)
), pn = function(e, t, r) {
  return new V(e, t, r);
}, hn = function(e, t, r, n) {
  return new sn(e, t, r, n);
}, vn = function(e, t, r, n) {
  return new $t(e, t, r, n);
}, yn = function(e, t, r, n) {
  return new an(e, t, r, n);
}, mn = function(e, t, r, n) {
  return new on(e, t, r, n);
}, gn = function(e, t, r, n) {
  return new cn(e, t, r, n);
}, Sn = function(e, t, r, n) {
  return new Pt(e, t, r, n);
}, In = Se(function(e) {
  return function(t) {
    return t != null && t < e;
  };
}), On = Se(function(e) {
  return function(t) {
    return t === e || t <= e;
  };
}), bn = Se(function(e) {
  return function(t) {
    return t != null && t > e;
  };
}), wn = Se(function(e) {
  return function(t) {
    return t === e || t >= e;
  };
}), _n = function(e, t, r) {
  var n = e[0], s = e[1];
  return new V(function(u) {
    return se(u) % n === s;
  }, t, r);
}, $n = function(e, t, r, n) {
  return new ln(e, t, r, n);
}, Pn = function(e, t, r) {
  return new V(new RegExp(e, t.$options), t, r);
}, jn = function(e, t, r, n) {
  return new un(e, t, r, n);
}, tt = {
  number: function(e) {
    return typeof e == "number";
  },
  string: function(e) {
    return typeof e == "string";
  },
  bool: function(e) {
    return typeof e == "boolean";
  },
  array: function(e) {
    return Array.isArray(e);
  },
  null: function(e) {
    return e === null;
  },
  timestamp: function(e) {
    return e instanceof Date;
  }
}, kn = function(e, t, r) {
  return new V(function(n) {
    if (typeof e == "string") {
      if (!tt[e])
        throw new Error("Type alias does not exist");
      return tt[e](n);
    }
    return n != null ? n instanceof e || n.constructor === e : !1;
  }, t, r);
}, En = function(e, t, r, n) {
  return new fn(e, t, r, n);
}, An = function(e, t, r, n) {
  return new dn(e, t, r, n);
}, qn = function(e, t, r) {
  return new wt(e, t, r, "$size");
}, Cn = function() {
  return null;
}, Fn = function(e, t, r) {
  var n;
  if (Yr(e))
    n = e;
  else if (!process.env.CSP_ENABLED)
    n = new Function("obj", "return " + e);
  else
    throw new Error('In CSP mode, sift does not support strings in "$where" condition');
  return new V(function(s) {
    return n.bind(s)(s);
  }, t, r);
}, Tn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  $Size: wt,
  $eq: pn,
  $ne: hn,
  $or: vn,
  $nor: yn,
  $elemMatch: mn,
  $nin: gn,
  $in: Sn,
  $lt: In,
  $lte: On,
  $gt: bn,
  $gte: wn,
  $mod: _n,
  $exists: $n,
  $regex: Pn,
  $not: jn,
  $type: kn,
  $and: En,
  $all: An,
  $size: qn,
  $options: Cn,
  $where: Fn
}), Ln = function(e, t, r) {
  var n = r === void 0 ? {} : r, s = n.compare, u = n.operations;
  return ie(e, t, {
    compare: s,
    operations: Object.assign({}, Tn, u || {})
  });
}, Bn = function(e, t) {
  t === void 0 && (t = {});
  var r = Ln(e, null, t);
  return nn(r);
};
function xe(e, t, r = "g") {
  const n = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\"];
  return t = t.replace(new RegExp(`(\\${n.join("|\\")})`, r), "\\$1"), t = t.replace(/%/g, ".*").replace(/_/g, "."), RegExp(`^${t}$`, r).test(e);
}
function jt(e, t) {
  return xe(e, t, "ig");
}
const Mn = (e, t, r) => ge((n) => xe(n, e), t, r), rt = (e, t, r) => ge((n) => !xe(n, e), t, r), nt = (e, t, r) => ge((n) => jt(n, e), t, r), Nn = (e, t, r) => ge((n) => !jt(n, e), t, r), Dn = {
  $like: Mn,
  $notLike: rt,
  $notlike: rt,
  $ilike: nt,
  $iLike: nt,
  $notILike: Nn
}, Rn = ["$sort", "$limit", "$skip", "$select"], Wn = [
  "$in",
  "$nin",
  "$exists",
  "eq",
  "ne",
  "$mod",
  "$all",
  "$not",
  "$size",
  "$type",
  "$regex",
  "$options",
  "$where",
  "$elemMatch"
];
function kt(e) {
  const {
    idField: t,
    itemStorage: r,
    tempStorage: n,
    cloneStorage: s,
    addItemToStorage: u,
    paramsForServer: o = [],
    whitelist: i = [],
    customSiftOperators: a = {}
  } = e, c = Object.assign({}, Dn, a), l = m(() => Wn.concat(i || []).concat(Object.keys(c))), d = (h, I = []) => {
    h = { ...C(h) };
    const p = o, _ = ne.omit(h.query || {}, ...p), { query: $, filters: P } = Yt(_, {
      operators: l.value
    });
    let q = I.concat(r.list.value);
    return n && h.temps && q.push(...n.list.value), P.$or && ($.$or = P.$or), P.$and && ($.$and = P.$and), q = q.filter(Bn($, { operations: c })), { values: q, filters: P };
  };
  function g(h) {
    const I = m(() => {
      const p = C(h);
      p.query && (p.query = W(p.query));
      const _ = d(p), $ = _.filters;
      let P = _.values;
      const q = P.length;
      return $.$sort && P.sort(Ht($.$sort)), $.$skip && (P = P.slice($.$skip)), typeof $.$limit < "u" && (P = P.slice(0, $.$limit)), {
        total: q,
        limit: $.$limit || 0,
        skip: $.$skip || 0,
        data: p.clones ? P.map((F) => F.clone ? F.clone(void 0, { useExisting: !0 }) : F) : P
      };
    });
    return {
      total: m(() => I.value.total),
      limit: m(() => I.value.limit),
      skip: m(() => I.value.skip),
      data: m(() => I.value.data)
    };
  }
  function f(h) {
    const I = g(h);
    return m(() => I.data.value[0] || null);
  }
  function S(h) {
    return m(() => {
      if (h = { ...C(h) }, !h.query)
        throw new Error("params must contain a query object");
      return h.query = ne.omit(h.query, ...Rn), g(h).total.value;
    });
  }
  const v = (h, I) => m(() => {
    h = C(h), I = X(C(I) || {}), I.query && (I.query = W(I.query));
    let p = null;
    const _ = r.getItem(h) && He(I, t)(r.getItem(h)), $ = n && n.getItem(h) && He(I, "__tempId")(n.getItem(h));
    return _ ? p = _ : $ && (p = $), I.clones && p.clone ? p.clone(void 0, { useExisting: !0 }) : p || null;
  });
  function b(h) {
    const { items: I, isArray: p } = Y(C(h)), _ = I.map(($) => u(C($)));
    return p ? _ : _[0];
  }
  function w(h, I = {}, p = {}) {
    const _ = C(h), $ = C(I), P = C(p);
    function q(F) {
      return F.map((A) => {
        if (A = C(A), (typeof A == "number" || typeof A == "string") && (A = v(A).value), A == null)
          return null;
        const N = { ...A, ...$ };
        return u(N);
      }).filter((A) => A);
    }
    if (_ === null) {
      if (P != null && P.query && !Object.keys(P == null ? void 0 : P.query).length)
        throw new Error(
          'cannot perform multiple patchInStore with an empty query. You must explicitly provide a query. To patch all items, try using a query that matches all items, like "{ id: { $exists: true } }"'
        );
      const F = g(P).data.value;
      return q(F);
    } else {
      const { items: F, isArray: M } = Y(_), A = q(F);
      return M ? A : A[0];
    }
  }
  function y(h, I) {
    if (h === null && (I != null && I.query) && Object.keys(I == null ? void 0 : I.query).length) {
      const p = s ? s.list.value : [], { values: _ } = d(I, p);
      return O(_);
    } else
      h !== null && O(h);
    return h;
  }
  function O(h) {
    const { items: I } = Y(h);
    return I.forEach((p) => {
      if (typeof p == "string")
        r.removeItem(p), n == null || n.removeItem(p), s == null || s.removeItem(p);
      else {
        if (p.__isClone)
          return s == null ? void 0 : s.remove(p);
        if (p.__isTemp)
          return n == null ? void 0 : n.remove(p);
        r.remove(p), n == null || n.remove(p), s == null || s.remove(p);
      }
    }), h;
  }
  return {
    findInStore: g,
    findOneInStore: f,
    countInStore: S,
    getFromStore: v,
    createInStore: b,
    patchInStore: w,
    removeFromStore: y
  };
}
const Qe = ({
  getId: e,
  onRead: t = (s) => s,
  beforeWrite: r = (s) => s,
  assign: n = (s, u) => Object.assign(s, u)
}) => {
  const s = Be({}), u = m(() => Object.values(s)), o = m(() => Object.keys(s)), i = (y) => {
    const O = e(y);
    return a(O);
  }, a = (y) => !!s[y], c = (y) => {
    const O = e(y), h = d(O);
    return h ? n(h, y) : f(O, y), d(O);
  }, l = (y) => {
    const O = e(y);
    return d(O);
  }, d = (y) => {
    const O = s[y];
    return O ? t(O) : null;
  }, g = (y) => {
    const O = e(y);
    return f(O, y);
  }, f = (y, O) => {
    if (y == null)
      throw new Error("item has no id");
    return R(s, y, r(O)), d(y);
  }, S = (y) => {
    const O = e(y);
    return v(O);
  }, v = (y) => {
    const O = a(y);
    return O && G(s, y), O;
  };
  return { byId: s, list: u, ids: o, getId: e, clear: () => {
    Object.keys(s).forEach((y) => {
      G(s, y);
    });
  }, has: i, hasItem: a, get: l, getItem: d, set: g, setItem: f, remove: S, removeItem: v, getKeys: () => o.value, merge: c };
}, Gn = (e) => {
  const { getId: t, itemStorage: r, onRead: n, beforeWrite: s } = e, u = Qe({
    getId: t,
    onRead: n,
    beforeWrite: s
  });
  function o(i) {
    return u.has(i) && u.remove(i), r.set(i);
  }
  return { tempStorage: u, moveTempToItems: o };
}, xn = (e) => {
  const { itemStorage: t, tempStorage: r, onRead: n, beforeWrite: s } = e, u = (f, S = {}, { isClone: v }) => X(Object.assign({}, f, S, { __isClone: v })), o = e.makeCopy || u, i = Qe({
    getId: (f) => {
      const S = t.getId(f);
      return S ?? r.getId(f);
    },
    onRead: n,
    beforeWrite: s
  });
  function a(f) {
    return f.__isClone || (t.has(f) ? t.merge(f) : r.has(f) && r.merge(f)), t.get(f) || r.get(f) || (t.getId(f) != null ? t.merge(f) : r.getId(f) != null && r.merge(f)), t.get(f) || r.get(f);
  }
  function c(f, S = {}, v = {}) {
    const b = i.get(f);
    return a(f), b && v.useExisting ? b : d(f, S);
  }
  function l(f, S = {}) {
    const v = t.getId(f), b = o(f, S, { isClone: !1 });
    return v ? (t.merge(b), t.get(b)) : (r.merge(b), r.get(b));
  }
  function d(f, S = {}) {
    const v = a(f);
    if (i.get(f)) {
      const w = o(v, S, { isClone: !0 });
      Object.keys(v).forEach((y) => {
        v[y] == null && G(w, y);
      }), i.merge(w);
    } else {
      const w = o(f, S, { isClone: !0 });
      i.set(w);
    }
    return i.get(f);
  }
  function g(f) {
    return Object.defineProperty(f, "__isClone", {
      writable: !1,
      enumerable: !1,
      value: !0
    }), f;
  }
  return {
    cloneStorage: i,
    clone: c,
    commit: l,
    reset: d,
    markAsClone: g
  };
}, Et = (e) => {
  const { getIdField: t, setupInstance: r } = e, n = (f, S = {}, { isClone: v }) => {
    const b = X(f);
    return Object.assign(b, S), Object.defineProperty(b, "__isTemp", {
      configurable: !0,
      enumerable: !1,
      get() {
        return this[this.__idField] == null;
      }
    }), ce(b, {
      __isClone: v,
      __tempId: f.__tempId
    });
  }, s = Qe({
    getId: t,
    beforeWrite: r,
    onRead: r
  }), { tempStorage: u, moveTempToItems: o } = Gn({
    getId: (f) => f.__tempId,
    itemStorage: s,
    beforeWrite: r,
    onRead: r
  }), { cloneStorage: i, clone: a, commit: c, reset: l, markAsClone: d } = xn({
    itemStorage: s,
    tempStorage: u,
    makeCopy: n,
    beforeWrite: (f) => (d(f), r(f)),
    onRead: r
  });
  return {
    itemStorage: s,
    tempStorage: u,
    cloneStorage: i,
    clone: a,
    commit: c,
    reset: l,
    addItemToStorage: (f) => {
      const S = t(f);
      return f = r(f), f.__isClone ? i.merge(f) : S != null && f.__tempId != null ? o(f) : S != null ? s.merge(f) : u && f.__tempId != null ? u == null ? void 0 : u.merge(f) : s.merge(f);
    }
  };
};
var Ce = {}, Qn = {
  get exports() {
    return Ce;
  },
  set exports(e) {
    Ce = e;
  }
}, Fe = {}, Un = {
  get exports() {
    return Fe;
  },
  set exports(e) {
    Fe = e;
  }
};
/*!
 * isomorphic-mongo-objectid - v@version@
 * Pure JavaScript implementation of mongodb ObjectId for the browser and server
 * https://github.com/john-doherty/isomorphic-mongo-objectid
 * @author John Doherty <www.johndoherty.info>
 * @license MIT
 */
(function(e) {
  (function() {
    var t = 0, r = Math.floor(Math.random() * 32767), n = Math.floor(Math.random() * 16777216);
    if (typeof window < "u") {
      var s = window.localStorage, u = parseInt(s.mongoMachineId, 10);
      u >= 0 && u <= 16777215 && (n = Math.floor(s.mongoMachineId)), s.mongoMachineId = n;
    }
    function o() {
      var i = arguments;
      if (!(this instanceof o))
        return i.length > 0 ? new o(i[0], i[1], i[2], i[3]) : new o();
      typeof i[0] == "object" ? (this.timestamp = i[0].timestamp, this.machine = i[0].machine, this.pid = i[0].pid, this.increment = i[0].increment) : typeof i[0] == "string" && i[0].length === 24 ? (this.timestamp = +("0x" + i[0].substr(0, 8)), this.machine = +("0x" + i[0].substr(8, 6)), this.pid = +("0x" + i[0].substr(14, 4)), this.increment = +("0x" + i[0].substr(18, 6))) : i.length === 4 && i[0] !== null ? (this.timestamp = i[0], this.machine = i[1], this.pid = i[2], this.increment = i[3]) : (this.timestamp = Math.floor((/* @__PURE__ */ new Date()).valueOf() / 1e3), this.machine = n, this.pid = r, this.increment = t++, t > 16777215 && (t = 0));
    }
    o.prototype.getDate = function() {
      return new Date(this.timestamp * 1e3);
    }, o.prototype.toArray = function() {
      var i = this.toString(), a = [], c;
      for (c = 0; c < 12; c++)
        a[c] = parseInt(i.slice(c * 2, c * 2 + 2), 16);
      return a;
    }, o.prototype.toString = function() {
      var i = this.timestamp.toString(16), a = this.machine.toString(16), c = this.pid.toString(16), l = this.increment.toString(16);
      return [
        "00000000".substr(0, 8 - i.length) + i,
        "000000".substr(0, 6 - a.length) + a,
        "0000".substr(0, 4 - c.length) + c,
        "000000".substr(0, 6 - l.length) + l
      ].join("");
    }, e.exports = o;
  })();
})(Un);
(function(e) {
  e.exports = Fe;
})(Qn);
const Vn = /* @__PURE__ */ Zt(Ce), At = (e, t) => {
  if (e.__isStoreInstance)
    return e;
  const { idField: r, clonesById: n, clone: s, commit: u, reset: o, createInStore: i, removeFromStore: a } = t, c = e.__isClone || !1;
  return Object.defineProperty(e, "__isTemp", {
    configurable: !0,
    enumerable: !1,
    get() {
      return this[this.__idField] == null;
    }
  }), ce(e, {
    __isStoreInstance: !0,
    __isClone: c,
    __idField: r,
    __tempId: e[r] == null && e.__tempId == null ? new Vn().toString() : e.__tempId || void 0,
    hasClone() {
      const d = this[this.__idField] || this.__tempId;
      return n[d] || null;
    },
    clone(d = {}, g = {}) {
      return s(this, d, g);
    },
    commit(d = {}) {
      return u(this, d);
    },
    reset(d = {}) {
      return o(this, d);
    },
    createInStore() {
      return i(this);
    },
    removeFromStore() {
      return a(this);
    }
  });
}, Jn = () => ({
  skipGetIfExists: !1
}), Ts = (e) => {
  const t = Object.assign({}, Jn(), e), { idField: r, customSiftOperators: n } = t;
  function s(p) {
    const _ = At(p, {
      idField: r,
      clonesById: i.byId,
      clone: a,
      commit: c,
      reset: l,
      createInStore: y,
      removeFromStore: h
    });
    if (p.__isSetup)
      return _;
    {
      const $ = t.setupInstance ? t.setupInstance(_) : _;
      return Object.defineProperty($, "__isSetup", { value: !0 }), $;
    }
  }
  const { itemStorage: u, tempStorage: o, cloneStorage: i, clone: a, commit: c, reset: l, addItemToStorage: d } = Et({
    getIdField: (p) => p[r],
    setupInstance: s
  }), g = m(() => !!C(t.ssr));
  function f() {
    u.clear(), o.clear(), i.clear();
  }
  const { findInStore: S, findOneInStore: v, countInStore: b, getFromStore: w, createInStore: y, patchInStore: O, removeFromStore: h } = kt({
    idField: r,
    itemStorage: u,
    tempStorage: o,
    cloneStorage: i,
    addItemToStorage: d,
    customSiftOperators: n
  });
  return {
    new: s,
    idField: r,
    isSsr: g,
    // items
    itemsById: u.byId,
    items: u.list,
    itemIds: u.ids,
    // temps
    tempsById: o.byId,
    temps: o.list,
    tempIds: o.ids,
    // clones
    clonesById: i.byId,
    clones: i.list,
    cloneIds: i.ids,
    clone: a,
    commit: c,
    reset: l,
    // local queries
    findInStore: S,
    findOneInStore: v,
    countInStore: b,
    createInStore: y,
    getFromStore: w,
    patchInStore: O,
    removeFromStore: h,
    clearAll: f
  };
};
var qt = {}, z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.createDebug = z.setDebug = z.noopDebug = void 0;
const ae = {};
function Ct() {
  return function() {
  };
}
z.noopDebug = Ct;
let Ft = Ct;
function Kn(e) {
  Ft = e, Object.keys(ae).forEach((t) => {
    ae[t] = e(t);
  });
}
z.setDebug = Kn;
function zn(e) {
  return ae[e] || (ae[e] = Ft(e)), (...t) => ae[e](...t);
}
z.createDebug = zn;
(function(e) {
  var t = fe && fe.__createBinding || (Object.create ? function(o, i, a, c) {
    c === void 0 && (c = a);
    var l = Object.getOwnPropertyDescriptor(i, a);
    (!l || ("get" in l ? !i.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return i[a];
    } }), Object.defineProperty(o, c, l);
  } : function(o, i, a, c) {
    c === void 0 && (c = a), o[c] = i[a];
  }), r = fe && fe.__exportStar || function(o, i) {
    for (var a in o)
      a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, o, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createSymbol = e.isPromise = e._ = e.stripSlashes = void 0;
  function n(o) {
    return o.replace(/^(\/+)|(\/+)$/g, "");
  }
  e.stripSlashes = n, e._ = {
    each(o, i) {
      o && typeof o.forEach == "function" ? o.forEach(i) : e._.isObject(o) && Object.keys(o).forEach((a) => i(o[a], a));
    },
    some(o, i) {
      return Object.keys(o).map((a) => [o[a], a]).some(([a, c]) => i(a, c));
    },
    every(o, i) {
      return Object.keys(o).map((a) => [o[a], a]).every(([a, c]) => i(a, c));
    },
    keys(o) {
      return Object.keys(o);
    },
    values(o) {
      return e._.keys(o).map((i) => o[i]);
    },
    isMatch(o, i) {
      return e._.keys(i).every((a) => o[a] === i[a]);
    },
    isEmpty(o) {
      return e._.keys(o).length === 0;
    },
    isObject(o) {
      return typeof o == "object" && !Array.isArray(o) && o !== null;
    },
    isObjectOrArray(o) {
      return typeof o == "object" && o !== null;
    },
    extend(o, ...i) {
      return Object.assign(o, ...i);
    },
    omit(o, ...i) {
      const a = e._.extend({}, o);
      return i.forEach((c) => delete a[c]), a;
    },
    pick(o, ...i) {
      return i.reduce((a, c) => (o[c] !== void 0 && (a[c] = o[c]), a), {});
    },
    // Recursively merge the source object into the target object
    merge(o, i) {
      return e._.isObject(o) && e._.isObject(i) && Object.keys(i).forEach((a) => {
        e._.isObject(i[a]) ? (o[a] || Object.assign(o, { [a]: {} }), e._.merge(o[a], i[a])) : Object.assign(o, { [a]: i[a] });
      }), o;
    }
  };
  function s(o) {
    return e._.isObject(o) && typeof o.then == "function";
  }
  e.isPromise = s;
  function u(o) {
    return typeof Symbol < "u" ? Symbol.for(o) : o;
  }
  e.createSymbol = u, r(z, e);
})(qt);
const Hn = (e) => {
  const { idField: t, isSsr: r } = e, n = e.defaultLimit || 10, s = j({});
  function u() {
    const { defaultLimit: c, defaultSkip: l } = s.value;
    s.value = { defaultLimit: c, defaultSkip: l };
  }
  function o({
    qid: c,
    response: l,
    query: d = {},
    preserveSsr: g = !1
  }) {
    var M, A;
    const { data: f, total: S } = l, v = f.map((N) => pe(N, t)), b = (/* @__PURE__ */ new Date()).getTime(), { queryId: w, queryParams: y, pageId: O, pageParams: h } = a({ qid: c, query: d });
    s.value[c] || R(s.value, c, {}), !K(d, "$limit") && K(l, "limit") && R(s.value, "defaultLimit", l.limit), !K(d, "$skip") && K(l, "skip") && R(s.value, "defaultSkip", l.skip);
    const I = {
      query: d,
      queryId: w,
      queryParams: y,
      pageId: O,
      pageParams: h,
      queriedAt: b,
      total: S
    }, p = (A = (M = s.value[c]) == null ? void 0 : M[w]) == null ? void 0 : A[O], _ = s.value[c] || {};
    Object.assign(_, { mostRecent: I }), R(_, w, _[w] || {});
    const $ = {
      total: S,
      queryParams: y
    };
    R(_, w, Object.assign({}, _[w], $));
    const P = g ? p == null ? void 0 : p.ssr : r.value, q = {
      [O]: { pageParams: h, ids: v, queriedAt: b, ssr: !!P }
    };
    Object.assign(_[w], q);
    const F = Object.assign({}, s.value[c], _);
    R(s.value, c, F);
  }
  function i(c) {
    var v, b;
    const l = a(c), { qid: d, queryId: g, pageId: f } = l, S = (b = (v = s.value[d]) == null ? void 0 : v[g]) == null ? void 0 : b[f];
    S.ssr = !1;
  }
  function a(c) {
    const l = W(c), { query: d = {} } = l, g = l.qid || "default", f = (d == null ? void 0 : d.$limit) || n, S = (d == null ? void 0 : d.$skip) || 0, v = f !== void 0 ? { $limit: f, $skip: S } : void 0, b = v ? he(v) : void 0, w = qt._.omit(d, "$limit", "$skip"), y = he(w);
    return {
      qid: g,
      query: d,
      queryId: y,
      queryParams: w,
      pageParams: v,
      pageId: b,
      isExpired: !1
    };
  }
  return {
    pagination: s,
    updatePaginationForQuery: o,
    unflagSsr: i,
    getQueryInfo: a,
    clearPagination: u
  };
}, st = () => ({
  find: 0,
  count: 0,
  get: 0,
  create: 0,
  update: 0,
  patch: 0,
  remove: 0
}), Yn = () => {
  const e = j(st()), t = j({}), r = j({}), n = j({}), s = j({}), u = m(() => e.value.find > 0), o = m(() => e.value.count > 0), i = m(() => e.value.get > 0), a = m(() => e.value.create > 0 || Object.keys(t.value).length > 0), c = m(() => e.value.update > 0 || Object.keys(r.value).length > 0), l = m(() => e.value.patch > 0 || Object.keys(n.value).length > 0), d = m(() => e.value.remove > 0 || Object.keys(s.value).length > 0);
  function g(b, w) {
    w ? e.value[b]++ : e.value[b]--;
  }
  function f(b, w, y) {
    if (b == null)
      return;
    let O;
    w === "create" ? O = t.value : w === "update" ? O = r.value : w === "patch" ? O = n.value : w === "remove" && (O = s.value), y ? R(O, b, !0) : G(O, b);
  }
  function S(...b) {
    b.forEach((w) => {
      w != null && (G(t.value, w), G(r.value, w), G(n.value, w), G(s.value, w));
    });
  }
  function v() {
    e.value = st(), t.value = {}, r.value = {}, n.value = {}, s.value = {};
  }
  return {
    isPending: e,
    createPendingById: t,
    updatePendingById: r,
    patchPendingById: n,
    removePendingById: s,
    isFindPending: u,
    isCountPending: o,
    isGetPending: i,
    isCreatePending: a,
    isUpdatePending: c,
    isPatchPending: l,
    isRemovePending: d,
    setPending: g,
    setPendingById: f,
    unsetPendingById: S,
    clearAllPending: v
  };
}, Xn = () => {
  const e = Be({
    created: {},
    patched: {},
    updated: {},
    removed: {}
  });
  function t(n, s) {
    const { items: u } = Y(n);
    u.forEach((o) => {
      e[s][o] ? r(n, s) : (R(e[s], o, !0), setTimeout(() => {
        r(n, s);
      }, 250));
    });
  }
  function r(n, s) {
    const { items: u } = Y(n);
    u.forEach((o) => {
      G(e[s], o);
    });
  }
  return { eventLocks: e, toggleEventLock: t, clearEventLock: r };
}, Zn = () => ({
  skipGetIfExists: !1
}), es = (e) => {
  const t = Object.assign({}, Zn(), e), { idField: r, whitelist: n, paramsForServer: s, defaultLimit: u, customSiftOperators: o } = t;
  function i(T) {
    const x = At(T, {
      idField: r,
      clonesById: d.byId,
      clone: g,
      commit: f,
      reset: S,
      createInStore: F,
      removeFromStore: A
    });
    if (T.__isSetup)
      return x;
    {
      const H = t.setupInstance ? t.setupInstance(x) : x;
      return Object.defineProperty(H, "__isSetup", { value: !0 }), H;
    }
  }
  const a = Yn(), { itemStorage: c, tempStorage: l, cloneStorage: d, clone: g, commit: f, reset: S, addItemToStorage: v } = Et({
    getIdField: (T) => T[r],
    setupInstance: i
  }), b = m(() => !!C(t.ssr)), { pagination: w, clearPagination: y, updatePaginationForQuery: O, getQueryInfo: h, unflagSsr: I } = Hn({
    idField: r,
    isSsr: b,
    defaultLimit: u
  });
  function p() {
    c.clear(), l.clear(), d.clear(), y(), a.clearAllPending();
  }
  const { findInStore: _, findOneInStore: $, countInStore: P, getFromStore: q, createInStore: F, patchInStore: M, removeFromStore: A } = kt({
    idField: r,
    itemStorage: c,
    tempStorage: l,
    cloneStorage: d,
    addItemToStorage: v,
    whitelist: n,
    paramsForServer: s,
    customSiftOperators: o
  }), N = Xn();
  return {
    new: i,
    idField: r,
    isSsr: b,
    defaultLimit: u,
    // items
    itemsById: c.byId,
    items: c.list,
    itemIds: c.ids,
    // temps
    tempsById: l.byId,
    temps: l.list,
    tempIds: l.ids,
    // clones
    clonesById: d.byId,
    clones: d.list,
    cloneIds: d.ids,
    clone: g,
    commit: f,
    reset: S,
    // local queries
    findInStore: _,
    findOneInStore: $,
    countInStore: P,
    createInStore: F,
    getFromStore: q,
    patchInStore: M,
    removeFromStore: A,
    clearAll: p,
    // server options
    whitelist: n,
    paramsForServer: s,
    // server pagination
    pagination: w,
    updatePaginationForQuery: O,
    unflagSsr: I,
    getQueryInfo: h,
    ...a,
    ...N
  };
}, U = {}, ts = (e) => `is${e.slice(0, 1).toUpperCase()}${e.slice(1, e.length - 1)}Pending`, rs = (e) => ({
  promise: null,
  isResolved: !1,
  getter: ts(e)
});
function Ls(e, t) {
  return U[t] = U[t] || rs(t), (!U[t].promise || U[t].isResolved) && (U[t].promise = new Promise((r) => {
    const n = ye(
      () => e[U[t].getter],
      async (s) => {
        s || setTimeout(() => {
          n(), U[t].isResolved = !0, r(U[t].isResolved);
        }, 0);
      },
      { immediate: !0 }
    );
  })), U[t].promise;
}
var Te = ns;
function ns(e, t, r, n) {
  var s, u, o;
  return function() {
    if (o = this, u = Array.prototype.slice.call(arguments), s && (r || n))
      return;
    if (!r)
      return c(), s = setTimeout(a, t), s;
    s = setTimeout(c, t), e.apply(o, u);
    function a() {
      c(), e.apply(o, u);
    }
    function c() {
      clearTimeout(s), s = null;
    }
  };
}
const ss = (e) => {
  if (!e.service || e.handleEvents === !1)
    return;
  const t = e.service, r = j({}), n = j({}), s = Te(
    async () => {
      const c = Object.values(r.value);
      c.length !== 0 && (t.store.createInStore(c), r.value = {});
    },
    e.debounceEventsTime || 20,
    void 0,
    e.debounceEventsGuarantee
  );
  function u(c) {
    const l = pe(c, t.store.idField);
    l && (R(r, l, c), K(n.value, l) && G(n, l), s());
  }
  const o = Te(
    () => {
      const c = Object.values(n.value);
      c.length !== 0 && (t.store.removeFromStore(c), n.value = {});
    },
    e.debounceEventsTime || 20,
    void 0,
    e.debounceEventsGuarantee
  );
  function i(c) {
    const l = pe(c, t.store.idField);
    l && (R(n, l, c), K(r.value, l) && G(r.value, l), o());
  }
  function a(c, l) {
    var f;
    const d = (f = e.handleEvents) == null ? void 0 : f[c];
    if (d === !1)
      return;
    const g = pe(l, t.store.idField);
    if (c !== "created" && t.store.eventLocks[c][g]) {
      t.store.toggleEventLock(g, c);
      return;
    }
    d && !d(l, { service: t }) || (e.debounceEventsTime ? c === "removed" ? i(l) : u(l) : c === "removed" ? t.store.removeFromStore(l) : t.store.createInStore(l));
  }
  t.on("created", (c) => {
    const l = re(t, c);
    a("created", l);
  }), t.on("updated", (c) => {
    const l = re(t, c);
    a("updated", l);
  }), t.on("patched", (c) => {
    const l = re(t, c);
    a("patched", l);
  }), t.on("removed", (c) => {
    const l = re(t, c);
    a("removed", l);
  });
}, os = () => async (e, t) => {
  if (e.params.query && (e.params.query = W(e.params.query)), e.method === "find") {
    const r = e.params.query || {};
    r.$limit == null && (r.$limit = e.service.store.defaultLimit), r.$skip == null && (r.$skip = 0), e.params.query = r;
  }
  await t();
}, is = () => async (e, t) => {
  var s, u, o;
  const r = e.service.store;
  let n;
  if (!r.isSsr) {
    const i = e.method === "find" ? ((s = e.params.query) == null ? void 0 : s.$limit) === 0 ? "count" : "find" : e.method;
    r.setPending(i, !0), e.id != null && i !== "get" && r.setPendingById(e.id, i, !0);
    const a = (u = e.data) == null ? void 0 : u.__isTemp, c = (o = e.data) == null ? void 0 : o.__tempId;
    a && i === "create" && r.setPendingById(e.data.__tempId, i, !0), n = () => {
      r.setPending(i, !1);
      const l = e.id != null ? e.id : c;
      l != null && i !== "get" && r.setPendingById(l, i, !1);
    };
  }
  try {
    await t();
  } catch (i) {
    throw n && n(), i;
  }
  n && n();
}, us = () => async (e, t) => {
  const { id: r, method: n } = e, s = e.service.store, u = ["update", "patch", "remove"].includes(n), i = {
    update: "updated",
    patch: "patched",
    remove: "removed"
  }[n];
  u && r && !s.isSsr && s.toggleEventLock(r, i), await t(), u && r && !s.isSsr && s.clearEventLock(r, i);
}, as = () => async (e, t) => {
  const { method: r, params: n } = e, s = e.service.store;
  if (r === "patch" && n.data && (e.data = n.data), t && await t(), !e.params.skipStore) {
    if (r === "remove")
      s.removeFromStore(e.result);
    else if (r === "create") {
      const u = Tr(e.data, e.result);
      e.result = s.createInStore(u);
    } else
      r === "find" && Array.isArray(e.result.data) ? e.result.data = s.createInStore(e.result.data) : e.result = s.createInStore(e.result);
    if (r === "find" && e.result.total) {
      const { qid: u = "default", query: o, preserveSsr: i = !1 } = e.params;
      s.updatePaginationForQuery({ qid: u, response: e.result, query: o, preserveSsr: i });
    }
  }
}, cs = () => async (e, t) => {
  var r;
  t && await t(), e.service.new && (Array.isArray((r = e.result) == null ? void 0 : r.data) ? e.result.data = e.result.data.map((n) => e.service.new(n)) : Array.isArray(e.result) ? e.result = e.result.map((n) => e.service.new(n)) : e.result = e.service.new(e.result));
};
function ls() {
  return async (e, t) => {
    const r = e.service.store;
    if (e.method === "find") {
      const { params: n } = e, s = r.getQueryInfo(n), u = r.pagination[s.qid], o = u == null ? void 0 : u[s.queryId], i = o == null ? void 0 : o[s.pageId];
      i != null && i.ssr && (e.result = {
        data: i.ids.map((a) => r.getFromStore(a).value),
        limit: i.pageParams.$limit,
        skip: i.pageParams.$skip,
        total: o.total,
        fromSsr: !0
      }, n.preserveSsr || r.unflagSsr(n));
    }
    t && await t();
  };
}
const fs = () => async (e, t) => {
  if (e.method === "find") {
    const { params: r } = e, { query: n = {} } = r;
    (r.paginate === !0 || K(n, "$limit") || K(n, "$skip")) && (r.paginate = { default: !0 });
  }
  t && await t(), e.method === "find" && e.result.data;
}, ds = () => async (e, t) => {
  const { params: r, id: n } = e, s = e.service.store;
  if (e.method === "get" && n != null) {
    const u = r.skipGetIfExists || s.skipGetIfExists;
    delete r.skipGetIfExists;
    const o = s.getFromStore(e.id, r);
    o && u && (e.result = o);
  }
  await t();
}, ps = () => async (e, t) => {
  const { method: r, data: n, params: s, id: u } = e, o = e.service.store;
  let i, a;
  const c = r === "patch" && !s.data && (n.__isClone || s.diff);
  if (c) {
    a = n;
    const l = o.getFromStore(u).value, d = Fr(l, a, s.diff);
    if (i = X(l), s.eager !== !1 && n.commit(d), s.with) {
      const g = je(a, s.with);
      typeof s.with != "string" && !Array.isArray(s.with) && Object.assign(g, s.with), Object.assign(d, g);
    }
    e.data = d, Object.keys(e.data).length === 0 && (e.result = a);
  } else
    e.data = X(n);
  try {
    await t();
  } catch (l) {
    throw c && a && a.commit(i), l;
  }
}, hs = () => [
  os(),
  is(),
  us(),
  as(),
  cs(),
  ls(),
  fs(),
  ds(),
  ps()
], vs = (e, t) => {
  if (e.__isServiceInstance)
    return e;
  const { service: r, store: n } = t, s = (u, o) => Object.assign(u, o);
  return mt(e, {
    isPending() {
      return this.isCreatePending || this.isPatchPending || this.isRemovePending;
    },
    isSavePending() {
      return this.isCreatePending || this.isPatchPending;
    },
    isCreatePending() {
      return !!(n.createPendingById[this[n.idField]] || n.createPendingById[this.__tempId]);
    },
    isPatchPending() {
      return !!n.patchPendingById[this[n.idField]];
    },
    isRemovePending() {
      return !!n.removePendingById[this[n.idField]];
    }
  }), ce(e, {
    __isServiceInstance: !0,
    save(u) {
      return this[n.idField] != null ? this.patch(u) : this.create(u);
    },
    create(u) {
      return r.create(this, u).then((o) => s(this, o));
    },
    patch(u) {
      const o = this[n.idField];
      if (o === void 0)
        throw new it("the item has no id");
      return r.patch(o, this, u).then((i) => s(this, i));
    },
    remove(u) {
      if (this.__isTemp)
        return n.removeFromStore(this.__tempId), Promise.resolve(this);
      {
        const o = this[n.idField];
        return r.remove(o, u).then((i) => s(this, i));
      }
    }
  }), e;
};
function ys(e, t) {
  const r = {};
  Object.keys(t).forEach((n) => {
    const s = e[n], u = t[n], o = this.service(u);
    if (o || console.error("there is no service at path " + u + "check your storeAssociated config", e, t), s && o) {
      const i = o.createInStore(s);
      r[n] = i;
    }
  }), ce(e, r);
}
function ms(e, t, r) {
  const n = JSON.stringify(t);
  r.setItem(e, n);
}
function gs(e, t) {
  const r = t.getItem(e.$id);
  if (r) {
    const n = JSON.parse(r) || {};
    Object.assign(e, n);
  }
}
function Ss(e, t, r = window.localStorage) {
  gs(e, r);
  const n = Te(ms, 500), s = m(() => ne.pick(e, ...t));
  ye(s, (u) => n(e.$id, u, r), { deep: !0 });
}
function Is(e = window.localStorage) {
  Object.keys(e).map((t) => {
    t.startsWith("service.") && e.removeItem(t);
  });
}
function Bs(e, t) {
  const r = Kt();
  r.defaultService = function(s) {
    var I;
    const u = ((I = t.services) == null ? void 0 : I[s]) || {}, o = u.idField || t.idField, i = u.defaultLimit || t.defaultLimit || 10, a = (u.whitelist || []).concat(t.whitelist || []), c = (u.paramsForServer || []).concat(t.paramsForServer || []), l = u.handleEvents || t.handleEvents, d = u.debounceEventsTime != null ? u.debounceEventsTime : t.debounceEventsTime, g = u.debounceEventsGuarantee != null ? u.debounceEventsGuarantee : t.debounceEventsGuarantee, f = Object.assign(
      {},
      u.customSiftOperators || {},
      t.customSiftOperators || {}
    );
    function S(p) {
      const _ = Object.assign(p, t.customizeStore ? t.customizeStore(p) : p);
      return Object.assign(
        _,
        u.customizeStore ? u.customizeStore(_) : _
      );
    }
    function v(p) {
      const _ = vs(p, {
        service: r.service(s),
        store: y
      }), $ = { app: r, service: r.service(s), servicePath: s }, P = t.setupInstance ? t.setupInstance(_, $) : _;
      return u.setupInstance ? u.setupInstance(p, $) : P;
    }
    const b = `service:${s}`, y = zt(b, () => {
      const p = es({
        idField: o,
        defaultLimit: i,
        whitelist: a,
        paramsForServer: c,
        customSiftOperators: f,
        ssr: t.ssr,
        setupInstance: v
      }), _ = S(p);
      return { ...p, ..._ };
    })(t.pinia);
    if (!t.ssr && t.storage) {
      const p = ["itemsById", "pagination"], _ = t.syncWithStorage === !0 ? p : Array.isArray(t.syncWithStorage) ? t.syncWithStorage : [], $ = u.syncWithStorage === !0 ? p : Array.isArray(u.syncWithStorage) ? u.syncWithStorage : [], P = [.../* @__PURE__ */ new Set([..._, ...$])];
      P.length > 0 && Ss(y, P, t.storage);
    }
    const O = e.service(s), h = new Jr(O, { store: y, servicePath: s });
    return ss({
      service: h,
      debounceEventsTime: d,
      debounceEventsGuarantee: g,
      handleEvents: l
    }), h;
  };
  const n = (s) => {
    s.hooks({
      around: hs()
    });
  };
  return r.mixins.push(n), mt(r, {
    authentication() {
      return e.authentication;
    },
    authenticate() {
      return e.authenticate;
    },
    reAuthenticate() {
      return e.reAuthenticate;
    },
    logout() {
      return e.logout;
    },
    clearStorage() {
      if (!t.ssr && t.storage)
        return Is(t.storage);
    }
  }), Object.assign(r, { storeAssociated: ys }), r;
}
class Ms extends Xt {
  async request(t, r) {
    const n = Object.assign({}, t, r.connection);
    n.headers = Object.assign({ Accept: "application/json" }, this.options.headers, n.headers), t.body && (n.body = t.body);
    try {
      const s = await this.connection.raw(t.url, n), { _data: u, status: o } = s;
      return o === 204 ? null : u;
    } catch (s) {
      throw console.error("feathers-ofetch request error", s), s;
    }
  }
}
const Ns = {
  "feathers-pinia": [
    "useServiceInstance",
    "useInstanceDefaults",
    "useDataStore",
    "useAuth",
    "createPiniaClient",
    "defineGetters",
    "defineSetters",
    "defineValues"
  ]
};
function Le(e) {
  this.message = e;
}
Le.prototype = new Error(), Le.prototype.name = "InvalidCharacterError";
var ot = typeof window < "u" && window.atob && window.atob.bind(window) || function(e) {
  var t = String(e).replace(/=+$/, "");
  if (t.length % 4 == 1)
    throw new Le("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var r, n, s = 0, u = 0, o = ""; n = t.charAt(u++); ~n && (r = s % 4 ? 64 * r + n : n, s++ % 4) ? o += String.fromCharCode(255 & r >> (-2 * s & 6)) : 0)
    n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(n);
  return o;
};
function Os(e) {
  var t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(r) {
      return decodeURIComponent(ot(r).replace(/(.)/g, function(n, s) {
        var u = s.charCodeAt(0).toString(16).toUpperCase();
        return u.length < 2 && (u = "0" + u), "%" + u;
      }));
    }(t);
  } catch {
    return ot(t);
  }
}
function ve(e) {
  this.message = e;
}
function bs(e, t) {
  if (typeof e != "string")
    throw new ve("Invalid token specified");
  var r = (t = t || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(Os(e.split(".")[r]));
  } catch (n) {
    throw new ve("Invalid token specified: " + n.message);
  }
}
ve.prototype = new Error(), ve.prototype.name = "InvalidTokenError";
function Ds(e) {
  const { api: t, servicePath: r, skipTokenCheck: n } = e, s = r ? t.service(r) : null, u = e.entityKey || "user", o = j(), i = async () => {
  }, a = async (E) => {
    throw E;
  }, c = e.onSuccess || i, l = e.onError || a, d = e.onInitSuccess || i, g = e.onInitError || i, f = e.onLogoutSuccess || i, S = e.onLogoutError || a, v = j(null), b = m(() => s && (s == null ? void 0 : s.getFromStore(v)).value || null), w = j(null), y = () => w.value = null, O = Xe(), h = m(() => !!O.count.value), I = j(!1), p = (E) => {
    const T = E[u];
    if (s && T) {
      const x = s.store.createInStore(T);
      v.value = x[s.store.idField] || x.__tempId;
    }
    return I.value = !0, E;
  }, _ = async (E) => (O.add(), y(), o.value = t.authenticate(E).then(p).then(async (T) => await c(T) || T).catch((T) => (w.value = T, l(T))).finally(() => {
    O.sub();
  }), o.value), $ = (E) => {
    try {
      const T = bs(E);
      return (/* @__PURE__ */ new Date()).getTime() > T.exp * 1e3;
    } catch {
      return !1;
    }
  }, P = j(!1), q = async () => (O.add(), o.value = t.authentication.getAccessToken().then((E) => {
    if (E && !n && $(E))
      throw t.authentication.removeAccessToken(), new it("accessToken expired");
  }).then(() => t.reAuthenticate()).then(p).then(async (E) => await d(E) || E).catch((E) => (E.value = E, g(E))).finally(() => {
    O.sub(), P.value = !0;
  }), o.value), F = Xe(), M = m(() => !!F.count.value), A = async () => (F.add(), t.logout().then((E) => (v.value = null, I.value = !1, E)).then(f).catch((E) => (E.value = E, S(E))).finally(() => F.sub())), N = j(null);
  return {
    user: b,
    error: w,
    isPending: h,
    isLogoutPending: M,
    isInitDone: P,
    isAuthenticated: I,
    loginRedirect: N,
    getPromise: () => o.value,
    isTokenExpired: $,
    authenticate: _,
    reAuthenticate: q,
    logout: A,
    clearError: y
  };
}
export {
  Ms as OFetch,
  Jr as PiniaService,
  Is as clearStorage,
  Bs as createPiniaClient,
  mt as defineGetters,
  Cs as defineSetters,
  ce as defineValues,
  us as eventLocks,
  Ns as feathersPiniaAutoImport,
  hs as feathersPiniaHooks,
  gs as hydrateStore,
  cs as makeModelInstances,
  fs as normalizeFind,
  is as setPending,
  ds as skipGetIfExists,
  ys as storeAssociated,
  as as syncStore,
  Ss as syncWithStorage,
  Et as useAllStorageTypes,
  Ds as useAuth,
  Ts as useDataStore,
  Ur as useFind,
  Vr as useGet,
  Fs as useInstanceDefaults,
  At as useModelInstance,
  Ls as useQueuePromise,
  xn as useServiceClones,
  Xn as useServiceEventLocks,
  ss as useServiceEvents,
  vs as useServiceInstance,
  kt as useServiceLocal,
  Hn as useServicePagination,
  Yn as useServicePending,
  Qe as useServiceStorage,
  es as useServiceStore,
  Gn as useServiceTemps,
  ms as writeToStorage
};
//# sourceMappingURL=feathers-pinia.js.map
