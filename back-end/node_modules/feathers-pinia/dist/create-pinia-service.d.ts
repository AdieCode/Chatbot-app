import type { FeathersService, Id } from '@feathersjs/feathers';
import type { AnyData, Params, Query } from './types';
import type { MaybeRef } from '@vueuse/core';
import type { UseFindOptions, UseFindParams, UseGetParams } from './use-find-get';
import type { ComputedRef } from 'vue-demi';
import { ServiceInstance } from './modeling';
interface PiniaServiceOptions {
    servicePath: string;
    store: any;
}
export declare class PiniaService<Svc extends FeathersService> {
    service: Svc;
    options: PiniaServiceOptions;
    store: any;
    servicePath: string;
    constructor(service: Svc, options: PiniaServiceOptions);
    /**
     * Prepare new "instances" outside of store
     *
     * Functionally upgrades plain data to a service model "instance".
     * - flags each record with `__isSetup` to avoid duplicate work.
     */
    new(data?: AnyData): any;
    find(_params?: MaybeRef<Params<Query>>): Promise<any>;
    findOne(_params?: MaybeRef<Params<Query>>): Promise<any>;
    count(_params?: MaybeRef<Params<Query>>): Promise<any>;
    get(id: Id, _params?: MaybeRef<Params<Query>>): Promise<any>;
    create(data: AnyData): Promise<any>;
    patch(id: Id, data: AnyData, _params?: MaybeRef<Params<Query>>): Promise<any>;
    remove(id: Id, _params?: MaybeRef<Params<Query>>): Promise<any>;
    findInStore(params?: MaybeRef<Params<Query>>): any;
    findOneInStore(params?: MaybeRef<Params<Query>>): any;
    countInStore(params?: MaybeRef<Params<Query>>): any;
    getFromStore(id: Id, params?: MaybeRef<Params<Query>>): ComputedRef<ServiceInstance<AnyData>>;
    createInStore(data: AnyData): any;
    patchInStore<M extends AnyData, Q extends AnyData>(idOrData: MaybeRef<M | M[] | Id | null>, data?: MaybeRef<AnyData>, params?: MaybeRef<Params<Q>>): any;
    removeFromStore(id?: Id, params?: MaybeRef<Params<Query>>): any;
    useFind(params: ComputedRef<UseFindParams | null>, options?: UseFindOptions): {
        paramsWithPagination: ComputedRef<{
            query: any;
            qid?: string | undefined;
            paginate?: boolean | import("./types").PaginationOptions | undefined;
            provider?: string | undefined;
            route?: Record<string, string> | undefined;
            headers?: Record<string, any> | undefined;
            temps?: boolean | undefined;
            clones?: boolean | undefined;
            ssr?: boolean | undefined;
            skipGetIfExists?: boolean | undefined;
            data?: any;
            preserveSsr?: boolean | undefined;
        }>;
        isSsr: ComputedRef<any>;
        qid: ComputedRef<string>;
        data: ComputedRef<any>;
        allLocalData: ComputedRef<any>;
        total: ComputedRef<any>;
        limit: any;
        skip: import("vue-demi").Ref<number>;
        currentQuery: ComputedRef<{
            ids: any;
            items: AnyData;
            total: any;
            queriedAt: any;
            queryState: any;
            ssr: any;
            qid: string;
            query: Query;
            queryId: string;
            queryParams: Query;
            pageParams: {
                $limit: MaybeRef<number>;
                $skip: MaybeRef<number> | undefined;
            } | undefined;
            pageId: string | undefined;
            isExpired: boolean;
        } | null>;
        cachedQuery: ComputedRef<{
            ids: any;
            items: AnyData;
            total: any;
            queriedAt: any;
            queryState: any;
            ssr: any;
            qid: string;
            query: Query;
            queryId: string;
            queryParams: Query;
            pageParams: {
                $limit: MaybeRef<number>;
                $skip: MaybeRef<number> | undefined;
            } | undefined;
            pageId: string | undefined;
            isExpired: boolean;
        } | null>;
        latestQuery: ComputedRef<import("./types").QueryInfoExtended | null>;
        previousQuery: ComputedRef<import("./types").QueryInfoExtended | null>;
        find: (p?: Params<Query> | undefined) => Promise<void>;
        request: import("vue-demi").Ref<{
            then: <TResult1 = import("./types").Paginated<AnyData>, TResult2 = never>(onfulfilled?: ((value: import("./types").Paginated<AnyData>) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
            catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<import("./types").Paginated<AnyData> | TResult>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<import("./types").Paginated<AnyData>>;
            readonly [Symbol.toStringTag]: string;
        } | null>;
        requestCount: import("vue-demi").Ref<number>;
        queryWhen: (_queryWhenFn: () => boolean) => void;
        isPending: ComputedRef<boolean>;
        haveBeenRequested: ComputedRef<boolean>;
        haveLoaded: ComputedRef<boolean>;
        error: ComputedRef<any>;
        clearError: () => null;
        pageCount: ComputedRef<number>;
        currentPage: import("vue-demi").WritableComputedRef<number>;
        canPrev: ComputedRef<boolean>;
        canNext: ComputedRef<boolean>;
        next: () => Promise<void>;
        prev: () => Promise<void>;
        toStart: () => Promise<void>;
        toEnd: () => Promise<void>;
        toPage: (page: number) => Promise<void>;
    };
    useGet(id: MaybeRef<Id | null>, params?: MaybeRef<UseGetParams>): {
        params: import("vue-demi").Ref<UseGetParams>;
        isSsr: ComputedRef<any>;
        data: ComputedRef<any>;
        ids: import("vue-demi").Ref<Id[]>;
        getFromStore: any;
        get: () => Promise<AnyData>;
        request: import("vue-demi").Ref<{
            then: <TResult1 = AnyData, TResult2 = never>(onfulfilled?: ((value: AnyData) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
            catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<AnyData | TResult>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<AnyData>;
            readonly [Symbol.toStringTag]: string;
        } | null>;
        requestCount: import("vue-demi").Ref<number>;
        queryWhen: (_queryWhenFn: () => boolean) => void;
        isPending: ComputedRef<boolean>;
        hasBeenRequested: ComputedRef<boolean>;
        hasLoaded: ComputedRef<boolean>;
        error: ComputedRef<any>;
        clearError: () => null;
    };
    useGetOnce(_id: MaybeRef<Id | null>, params?: MaybeRef<UseGetParams>): {
        params: import("vue-demi").Ref<UseGetParams>;
        isSsr: ComputedRef<any>;
        data: ComputedRef<any>;
        ids: import("vue-demi").Ref<Id[]>;
        getFromStore: any;
        get: () => Promise<AnyData>;
        request: import("vue-demi").Ref<{
            then: <TResult1 = AnyData, TResult2 = never>(onfulfilled?: ((value: AnyData) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
            catch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<AnyData | TResult>;
            finally: (onfinally?: (() => void) | null | undefined) => Promise<AnyData>;
            readonly [Symbol.toStringTag]: string;
        } | null>;
        requestCount: import("vue-demi").Ref<number>;
        queryWhen: (_queryWhenFn: () => boolean) => void;
        isPending: ComputedRef<boolean>;
        hasBeenRequested: ComputedRef<boolean>;
        hasLoaded: ComputedRef<boolean>;
        error: ComputedRef<any>;
        clearError: () => null;
    };
    on(eventName: string | symbol, listener: (...args: any[]) => void): Svc;
    emit(eventName: string | symbol, ...args: any[]): boolean;
    removeListener(eventName: string | symbol, listener: (...args: any[]) => void): Svc;
}
export {};
