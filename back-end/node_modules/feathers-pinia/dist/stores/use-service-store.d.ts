import type { Query } from '@feathersjs/feathers';
import type { AnyData } from '../types';
import { MaybeRef } from '@vueuse/core';
export interface UseServiceStoreOptions {
    idField: string;
    defaultLimit?: number;
    whitelist?: string[];
    paramsForServer?: string[];
    skipGetIfExists?: boolean;
    ssr?: MaybeRef<boolean>;
    customSiftOperators?: Record<string, any>;
    setupInstance?: any;
}
export declare const useServiceStore: <M extends AnyData, Q extends Query>(_options: UseServiceStoreOptions) => {
    eventLocks: {
        created: {
            [key: string]: boolean;
        };
        patched: {
            [key: string]: boolean;
        };
        updated: {
            [key: string]: boolean;
        };
        removed: {
            [key: string]: boolean;
        };
    };
    toggleEventLock: (data: import("../types").MaybeArray<import("@feathersjs/feathers").Id>, event: import("./types").EventName) => void;
    clearEventLock: (data: import("../types").MaybeArray<import("@feathersjs/feathers").Id>, event: import("./types").EventName) => void;
    isPending: import("vue-demi").Ref<{
        find: number;
        count: number;
        get: number;
        create: number;
        update: number;
        patch: number;
        remove: number;
    }>;
    createPendingById: import("vue-demi").Ref<Record<string | number | symbol, true>>;
    updatePendingById: import("vue-demi").Ref<Record<string | number | symbol, true>>;
    patchPendingById: import("vue-demi").Ref<Record<string | number | symbol, true>>;
    removePendingById: import("vue-demi").Ref<Record<string | number | symbol, true>>;
    isFindPending: import("vue-demi").ComputedRef<boolean>;
    isCountPending: import("vue-demi").ComputedRef<boolean>;
    isGetPending: import("vue-demi").ComputedRef<boolean>;
    isCreatePending: import("vue-demi").ComputedRef<boolean>;
    isUpdatePending: import("vue-demi").ComputedRef<boolean>;
    isPatchPending: import("vue-demi").ComputedRef<boolean>;
    isRemovePending: import("vue-demi").ComputedRef<boolean>;
    setPending: (method: "find" | "count" | "get" | "create" | "update" | "patch" | "remove", value: boolean) => void;
    setPendingById: (id: import("@feathersjs/feathers").NullableId, method: import("./types").RequestTypeById, val: boolean) => void;
    unsetPendingById: (...ids: import("@feathersjs/feathers").NullableId[]) => void;
    clearAllPending: () => void;
    new: <N extends M>(this: any, data: N) => any;
    idField: string;
    isSsr: import("vue-demi").ComputedRef<boolean>;
    defaultLimit: number | undefined;
    itemsById: import("../types").ById<M>;
    items: import("vue-demi").ComputedRef<M[]>;
    itemIds: import("vue-demi").ComputedRef<string[]>;
    tempsById: import("../types").ById<M>;
    temps: import("vue-demi").ComputedRef<M[]>;
    tempIds: import("vue-demi").ComputedRef<string[]>;
    clonesById: import("../types").ById<M>;
    clones: import("vue-demi").ComputedRef<M[]>;
    cloneIds: import("vue-demi").ComputedRef<string[]>;
    clone: (item: M, data?: {}, options?: import("./types").CloneOptions) => M;
    commit: (item: M, data?: Partial<M>) => M;
    reset: (item: M, data?: {}) => M;
    findInStore: (_params: MaybeRef<import("../types").Params<Q>>) => {
        total: import("vue-demi").ComputedRef<number>;
        limit: import("vue-demi").ComputedRef<any>;
        skip: import("vue-demi").ComputedRef<any>;
        data: import("vue-demi").ComputedRef<any[]>;
    };
    findOneInStore: (params: MaybeRef<import("../types").Params<Q>>) => import("vue-demi").ComputedRef<any>;
    countInStore: (params: MaybeRef<import("../types").Params<Q>>) => import("vue-demi").ComputedRef<number>;
    createInStore: <N_1 = MaybeRef<M | M[]>>(data: N_1) => N_1;
    getFromStore: (id: MaybeRef<import("@feathersjs/feathers").Id | null>, params?: import("../types").Params<Q> | undefined) => import("vue-demi").ComputedRef<M | null>;
    patchInStore: (_idOrData: MaybeRef<M | import("@feathersjs/feathers").Id | M[] | null>, _data?: MaybeRef<AnyData>, _params?: MaybeRef<import("../types").Params<Q>>) => any;
    removeFromStore: (data: M | M[] | null, params?: import("../types").Params<Q> | undefined) => M | M[] | null;
    clearAll: () => void;
    whitelist: string[] | undefined;
    paramsForServer: string[] | undefined;
    pagination: import("vue-demi").Ref<import("./types").PaginationState>;
    updatePaginationForQuery: ({ qid, response, query, preserveSsr, }: import("./types").UpdatePaginationForQueryOptions) => void;
    unflagSsr: (params: import("../types").Params<import("../types").Query>) => void;
    getQueryInfo: (_params: import("../types").Params<import("../types").Query>) => import("../types").QueryInfo;
};
