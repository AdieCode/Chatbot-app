'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var supportedTypes = ['text', 'photo', 'audio', 'voice', 'video', 'video_note', 'document', 'sticker', 'contact', 'location', 'venue'];

var mediaTypes = ['photo', 'audio', 'voice', 'video', 'video_note', 'document', 'sticker'];

var Message = function () {
  function Message(message) {
    _classCallCheck(this, Message);

    Object.assign(this, message);
  }

  _createClass(Message, [{
    key: 'getCreator',
    value: function getCreator() {
      return this.forward_from ? this.forward_from.id : this.from.id;
    }
  }, {
    key: 'getCreatorSentAt',
    value: function getCreatorSentAt() {
      return this.forward_date ? new Date(this.forward_date * 1000) : new Date(this.date * 1000);
    }
  }, {
    key: 'getEditedAt',
    value: function getEditedAt() {
      return this.edit_date ? new Date(this.edit_date * 1000) : new Date(this.date * 1000);
    }
  }, {
    key: 'getSentAt',
    value: function getSentAt() {
      return new Date(this.date * 1000);
    }
  }, {
    key: 'getType',
    value: function getType() {
      var type = void 0;
      for (var key in this) {
        supportedTypes.forEach(function (supportedType) {
          if (key == supportedType) {
            type = key;
          }
        });
      }
      return type;
    }
  }, {
    key: 'hasEntity',
    value: function hasEntity(entityType) {
      var entities = this.entities;
      var hasEntity = false;
      if (entities && entities.length) {
        entities.forEach(function (entity) {
          if (entity.type == entityType) hasEntity = true;
        });
      }
      return hasEntity;
    }
  }, {
    key: 'isBotCommand',
    value: function isBotCommand() {
      if (this.hasEntity('bot_command')) {
        // Any slash following a string receives the bot command entity
        if (this.text.indexOf('/') == 0) {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: 'getMediaId',
    value: function getMediaId() {
      var type = this.getType();
      var media = this[type];
      if (Array.isArray(media) && media[0].file_id) {
        return media.map(function (item) {
          return item.file_id;
        });
      } else if (media.file_id) {
        return media.file_id;
      } else {
        return null;
      }
    }
  }, {
    key: 'getContent',
    value: function getContent() {
      var type = this.getType();
      if (mediaTypes.indexOf(type) !== -1) {
        return this.caption || null;
      } else {
        return this[type];
      }
    }
  }, {
    key: 'getUrls',
    value: function getUrls() {
      var _this = this;

      var urls = [];
      if (this.entities && this.entities.length) {
        this.entities.forEach(function (entity) {
          if (entity.type == 'url') {
            var start = entity.offset;
            var end = start + entity.length;
            urls.push({
              url: _this.text.slice(start, end),
              offset: entity.offset,
              length: entity.length
            });
          }
        });
      }
      return urls;
    }
  }, {
    key: 'toPost',
    value: function toPost() {
      var type = this.getType();
      if (type !== undefined && !this.isBotCommand()) {
        var post = {
          id: this.message_id,
          sentAt: this.getSentAt(),
          creatorSentAt: this.getCreatorSentAt(),
          editedAt: this.getEditedAt(),
          type: type,
          content: this.getContent(),
          mediaId: this.getMediaId(),
          userId: this.from.id,
          chatId: this.chat.id,
          creatorId: this.getCreator()
        };
        if (this.entities) {
          post.entities = this.entities;
        }
        return post;
      }
      return false;
    }
  }]);

  return Message;
}();

exports.default = Message;
module.exports = exports['default'];